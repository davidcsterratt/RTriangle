triangle.check.na.nan <- function(x) {
  if (!is.null(x)) {
    if (any(is.nan(x))) {
      stop(paste("NaN in", deparse(substitute(x))))
    }
    if (any(is.na(x))) {
      stop(paste("NA in", deparse(substitute(x))))
    }
  }
}

##if (is.loaded("R_triangulate")) dyn.unload("R_triangle.so")
##dyn.load("R_triangle.so")

triangulate <- function(P, S=NULL, a=NULL, q=NULL, Y=FALSE, j=FALSE,
                        V=0, Q=FALSE) {
  ## It is necessary to check for NAs and NaNs, as the triangulate C
  ## code crashes if fed with them
  triangle.check.na.nan(P)
  triangle.check.na.nan(S)
  triangle.check.na.nan(a)
  triangle.check.na.nan(q)
  triangle.check.na.nan(V)

  ## Deal with P
  if (ncol(P) == 2) {
    P <- t(P)
  }
  PB <- rep(1, ncol(P))

  ## Deal with S
  if (is.null(S)) {
    S <- rbind(1:ncol(P), c(2:ncol(P),1))
  } else {
    if (ncol(S) == 2) {
      S <- t(S)
    }
  }
  SB <- rep(1, ncol(S))
  
  ## Call the main routine
  out <- .Call("R_triangulate",
               P,
               as.integer(PB),
               as.integer(S),
               as.integer(SB),
               a,
               q,
               Y,
               j,
               as.integer(V),
               Q)
  names(out) <- c("P", "PB", "T", "S", "SB", "E", "EB")
  return(out)
}
